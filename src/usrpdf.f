
C--   This is the file usrpdf.f with user pdf output routines

C--   subroutine chkpdf(itype)
C--   subroutine fpdfxq(jset,xx,qq,pdf,jchk)
C--   subroutine fpdfij(jset,ix,iq,pdf,jchk)
C--   double precision function fsnsxq(jset,id,xx,qq,jchk) 
C--   double precision function fsnsij(jset,id,ix,iq,jchk)
C--   double precision function fvalxq(jset,xx,qq,jchk)
C--   double precision function fvalij(jset,id,ix,iq,jchk)
C--   double precision function fsumxq(jset,def,xx,qq,jchk)
C--   double precision function fsumij(jset,def,ix,iq,jchk)
C--   double precision function fsplne(jset,id,xx,iq)
C--   double precision function splchk(jset,id,iq)
C--   subroutine PdfLst(jset,def,x,q,f,n,jchk)
C--   subroutine PdfTab(jset,def,xx,nx,qq,nq,pdf,jchk)
C--   subroutine PdfInp(subr,jset,offset,epsi,nwlast) 

C==   ===============================================================
C==   Unpol/pol/frag/custom =========================================
C==   ===============================================================

C     ==============================      
      logical function chkpdf(itype)
C     ==============================      
      
C--   Check if itype exists

      implicit double precision (a-h,o-z)

      include 'qcdnum.inc'
      include 'qstor7.inc'

      logical first
      save    first
      data    first /.true./

      character*80 subnam
      data subnam /'CHKPDF ( ITYPE )'/

C--   Check if QCDNUM is initialized
      if(first) then
        call sqcChkIni(subnam)
        first = .false.
      endif 
C--   Check input value of itype      
      call sqcIlele(subnam,'ITYPE',1,itype,mset0,' ') 

      if(mxord7(itype).eq.0) then
        chkpdf = .false.
      else
        chkpdf = .true.  
      endif
      
      return
      end

C==   ===============================================================
C==   Pdf interpolation  ============================================
C==   ===============================================================

C     ======================================
      subroutine fpdfxq(jset,xx,qq,pdf,jchk)
C     ======================================

C--   Get all pdfs generated by s/r evolve.
C--
C--   Input    jset    : pdf set [1-9]
C--            jchk # 0: error if xx,qq out of range
C--                 = 0: return null if xx,qq out of range
C--   Output   pdf(-6:6) the whole lot...

      implicit double precision (a-h,o-z)

      include 'qcdnum.inc'
      include 'qpars6.inc'
 
      logical first
      save    first
      data    first /.true./

      save      ichk,       iset,       idel
      dimension ichk(mbp0), iset(mbp0), idel(mbp0)

      logical Lin, lqcInside

      dimension pdf(-6:6),val(0:12)

      character*80 subnam
      data subnam /'FPDFXQ ( ISET, X, QMU2, PDFS, ICHK )'/

C--   Initialize flagbits
      if(first) then
        call sqcMakeFl(subnam,ichk,iset,idel)
        first = .false.
      endif
C--   Check pdf set
      call sqcIlele(subnam,'ISET',1,jset,mset0,' ')      
C--   Check status bits
      call sqcChkflg(jset,ichk,subnam)

      Lin = lqcInside(xx,qq,ifail)
      if(Lin)                     then
C--     x and qmu2 inside grid      
C--          0  1  2  3  4  5  6  7  8  9 10 11 12 
C--     val  g  d+ u+ s+ c+ b+ t+ d- u- s- c- b- t-      
        call sqcAllQpQmyt(jset,-log(xx),log(qq),val)
C--     Copy val to pdf
C--          -6 -5 -4 -3 -2 -1 0  1  2  3  4  5  6
C--     pdf  tb bb cb sb ub db g  d  u  s  c  b  t
        pdf(0) = val(0)
        do i = 1,6
          pdf( i) = 0.5*(val(i)+val(6+i))
          pdf(-i) = 0.5*(val(i)-val(6+i))
        enddo
        
      elseif(jchk.ne.0)           then
C--     x or qmu2 outside grid gives fatal error      
        call sqcCutMsg(subnam,xx,qq,ifail,0)
        
      else 
C--     x or qmu2 outside grid sets pdfs to null         
        do i = -6,6
          pdf(i) = qnull6
        enddo
      endif
      
      return
      end
        
C     ======================================
      subroutine fpdfij(jset,ix,iq,pdf,jchk)
C     ======================================

C--   Get all pdfs generated by s/r evolve.
C--
C--   Input    jset    : pdf set [1-9]
C--            jchk # 0: error if ix,iq out of range
C--                 = 0: return null if ix,iq out of range
C--   Output   pdf(-6:6) the whole lot...

      implicit double precision (a-h,o-z)

      include 'qcdnum.inc'
      include 'qgrid2.inc'
      include 'qpars6.inc'
      include 'qpdfs7.inc'
 
      logical first
      save    first
      data    first /.true./

      save      ichk,       iset,       idel
      dimension ichk(mbp0), iset(mbp0), idel(mbp0)

      dimension pdf(-6:6),val(0:12)

      character*80 subnam
      data subnam /'FPDFIJ ( ISET, IX, IQ, PDFS, ICHK )'/

C--   Initialize flagbits
      if(first) then
        call sqcMakeFl(subnam,ichk,iset,idel)
        first = .false.
      endif
C--   Check pdf set
      call sqcIlele(subnam,'ISET',1,jset,mset0,' ')      
C--   Check status bits
      call sqcChkflg(jset,ichk,subnam)
C--   Check user input
      ixmi = nyy2(0)+1-iymac2
      iqmi = itfiz2(izmic2)
      iqma = itfiz2(izmac2)
      if(jchk.ne.0) then
        call sqcIlele(subnam,'IX',ixmi,ix,nyy2(0),' ')
        iy = nyy2(0)+1-ix
        call sqcIlele(subnam,'IQ',iqmi,iq,iqma,' ')
        it = iq
      else
        do i = -6,6
          pdf(i) = qnull6
        enddo
        if(ix.lt.ixmi .or. ix.gt.nyy2(0))    return !ix out of range
        iy = nyy2(0)+1-ix
        if(iq.lt.iqmi .or. iq.gt.iqma)       return !iq out of range
        it = iq
      endif
      
C--   Go ...
C--        0  1  2  3  4  5  6  7  8  9 10 11 12 
C--   val  g  d+ u+ s+ c+ b+ t+ d- u- s- c- b- t-
      call sqcAllQpQmij(jset,iy,it,val)
C--   Copy val to pdf
C--        0 -6 -5 -4 -3 -2 -1  1  2  3  4  5  6
C--   pdf  g tb bb cb sb ub db  d  u  s  c  b  t
      pdf(0) = val(0)
      do i = 1,6
        pdf( i) = 0.5*(val(i)+val(6+i))
        pdf(-i) = 0.5*(val(i)-val(6+i))
      enddo
      
      return
      end 
      
C     ====================================================
      double precision function fsnsxq(jset,id,xx,qq,jchk)
C     ====================================================

C--   Get si/ns pdf
C--
C--   Input    jset    : pdf set [1-9]
C--            id      : g, si, ns identifier [0,12]  
C--            jchk # 0: error if xx,qq out of range
C--                 = 0: return null if xx,qq out of range

      implicit double precision (a-h,o-z)

      include 'qcdnum.inc'
      include 'qpars6.inc'
 
      logical first
      save    first
      data    first /.true./

      save      ichk,       iset,       idel
      dimension ichk(mbp0), iset(mbp0), idel(mbp0)

      logical Lin, lqcInside

      character*80 subnam
      data subnam /'FSNSXQ ( ISET, ID, X, QMU2, ICHK )'/

C--   Initialize flagbits
      if(first) then
        call sqcMakeFl(subnam,ichk,iset,idel)
        first = .false.
      endif
C--   Check pdf set
      call sqcIlele(subnam,'ISET',1,jset,mset0,' ')      
C--   Check status bits
      call sqcChkflg(jset,ichk,subnam)
C--   Check user input
      call sqcIlele(subnam,'ID',0,id,12,' ')
      
      fsnsxq = qnull6   !avoid compiler warning                  

      Lin = lqcInside(xx,qq,ifail)
      if(Lin)                     then
C--     x and qmu2 inside grid            
        fsnsxq = dqcEpmyt(jset,id,-log(xx),log(qq))
        
      elseif(jchk.ne.0)           then
C--     x or qmu2 outside grid gives fatal error
        call sqcCutMsg(subnam,xx,qq,ifail,0)
        
      else 
C--     x or qmu2 outside grid sets pdfs to null         
        fsnsxq = qnull6
      endif
      
      return
      end
      
C     ====================================================
      double precision function fsnsij(jset,id,ix,iq,jchk)
C     ====================================================

C--   Get si/ns pdf
C--
C--   Input    jset    : pdf set [1-9]
C--            id      : g, si, ns identifier [0,12]
C--            jchk # 0: error if ix, iq out of range
C--                 = 0: return null if ix, iq out of range

      implicit double precision (a-h,o-z)

      include 'qcdnum.inc'
      include 'qgrid2.inc'
      include 'qpars6.inc'
      include 'qstor7.inc'
      include 'qpdfs7.inc'
 
      logical first
      save    first
      data    first /.true./

      save      ichk,       iset,       idel
      dimension ichk(mbp0), iset(mbp0), idel(mbp0)

      character*80 subnam
      data subnam /'FSNSIJ ( ISET, ID, IX, IQ, ICHK )'/

C--   Initialize flagbits
      if(first) then
        call sqcMakeFl(subnam,ichk,iset,idel)
        first = .false.
      endif
C--   Check pdf set
      call sqcIlele(subnam,'ISET',1,jset,mset0,' ')      
C--   Check status bits
      call sqcChkflg(jset,ichk,subnam)
C--   Check user input
      call sqcIlele(subnam,'ID',0,id,12,' ')
      ixmi = nyy2(0)+1-iymac2
      iqmi = itfiz2(izmic2)
      iqma = itfiz2(izmac2)
      if(jchk.ne.0) then
        call sqcIlele(subnam,'IX',ixmi,ix,nyy2(0),' ')
        iy = nyy2(0)+1-ix
        call sqcIlele(subnam,'IQ',iqmi,iq,iqma,' ')
        it = iq
      else
        fsnsij = qnull6
        if(ix.lt.ixmi .or. ix.gt.nyy2(0))    return !ix out of range
        iy = nyy2(0)+1-ix
        if(iq.lt.iqmi .or. iq.gt.iqma)       return !iq out of range
        it = iq
      endif
      
C--   Go ...
      iz = izfit2(it)
      ia = iqcPdfIjkl(iy,iz,id,jset)
      fsnsij = stor7(ia)
      
      return
      end
      
C     ====================================================
      double precision function fvalxq(jset,id,xx,qq,jchk)
C     ====================================================

C--   Get gluon, quarks or antiquarks
C--
C--   Input    jset    : pdf set [1-9]
C--            id      : gluon, q qbar identifier [-6,6]
C--            jchk # 0: error if xx,qq out of range
C--                 = 0: return null if xx,qq out of range

      implicit double precision (a-h,o-z)

      include 'qcdnum.inc'
      include 'qpars6.inc'
 
      logical first
      save    first
      data    first /.true./

      save      ichk,       iset,       idel
      dimension ichk(mbp0), iset(mbp0), idel(mbp0)

      logical Lin, lqcInside

      character*80 subnam
      data subnam /'FVALXQ ( ISET, ID, X, QMU2, ICHK )'/

C--   Initialize flagbits
      if(first) then
        call sqcMakeFl(subnam,ichk,iset,idel)
        first = .false.
      endif
C--   Check pdf set
      call sqcIlele(subnam,'ISET',1,jset,mset0,' ')      
C--   Check status bits
      call sqcChkflg(jset,ichk,subnam)
C--   Check user input
      call sqcIlele(subnam,'ID',-6,id,6,' ')

      fvalxq = qnull6   !avoid compiler warning                  

      Lin = lqcInside(xx,qq,ifail)
      if(Lin)                     then
C--     x and qmu2 inside grid            
        call sqcQpQmyt(jset,abs(id),-log(xx),log(qq),qplus,qminu)
        if(id.ge.0)     then
          fvalxq = 0.5D0 * (qplus+qminu)
        else
          fvalxq = 0.5D0 * (qplus-qminu)
        endif
        
      elseif(jchk.ne.0)           then
C--     x or qmu2 outside grid gives fatal error
        call sqcCutMsg(subnam,xx,qq,ifail,0)      
        
      else 
C--     x or qmu2 outside grid sets pdfs to null         
        fvalxq = qnull6
      endif
            
      return
      end
      
C     ====================================================
      double precision function fvalij(jset,id,ix,iq,jchk)
C     ====================================================

C--   Get gluon, quarks or antiquarks
C--
C--   Input    jset    : pdf set [1-9]
C--            id      : gluon, q qbar identifier [-6,6]
C--            jchk # 0: error if xx,qq out of range
C--                 = 0: return null if xx,qq out of range

      implicit double precision (a-h,o-z)

      include 'qcdnum.inc'
      include 'qgrid2.inc'
      include 'qpars6.inc'
      include 'qpdfs7.inc'
 
      logical first
      save    first
      data    first /.true./

      save      ichk,       iset,       idel
      dimension ichk(mbp0), iset(mbp0), idel(mbp0)

      character*80 subnam
      data subnam /'FVALIJ ( ISET, ID, IX, IQ, ICHK )'/

C--   Initialize flagbits
      if(first) then
        call sqcMakeFl(subnam,ichk,iset,idel)
        first = .false.
      endif
C--   Check pdf set
      call sqcIlele(subnam,'ISET',1,jset,mset0,' ')      
C--   Check status bits
      call sqcChkflg(jset,ichk,subnam)
C--   Check user input
      call sqcIlele(subnam,'ID',-6,id,6,' ')
      ixmi = nyy2(0)+1-iymac2
      iqmi = itfiz2(izmic2)
      iqma = itfiz2(izmac2)
      if(jchk.ne.0) then
        call sqcIlele(subnam,'IX',ixmi,ix,nyy2(0),' ')
        iy = nyy2(0)+1-ix
        call sqcIlele(subnam,'IQ',iqmi,iq,iqma,' ')
        it = iq
      else
        fvalij = qnull6
        if(ix.lt.ixmi .or. ix.gt.nyy2(0))    return !ix out of range
        iy = nyy2(0)+1-ix
        if(iq.lt.iqmi .or. iq.gt.iqma)       return !iq out of range
        it = iq
      endif
      
C--   Go ...
      call sqcQpQmij(jset,abs(id),iy,it,qplus,qminu)
      if(id.ge.0)     then
        fvalij = 0.5D0 * (qplus+qminu)
      else
        fvalij = 0.5D0 * (qplus-qminu)
      endif  
      
      return
      end
      
C     =====================================================
      double precision function fsumxq(jset,def,xx,qq,jchk)
C     =====================================================

C--   Weighted sum of quarks and antiquarks
C--
C--   Input    jset    : pdf set [1-9]
C--            jchk # 0: error if xx,qq out of range
C--                 = 0: return null if xx,qq out of range

      implicit double precision (a-h,o-z)

      include 'qcdnum.inc'
      include 'qpars6.inc'

      dimension def(-6:6)
 
      logical first
      save    first
      data    first /.true./

      save      ichk,       iset,       idel
      dimension ichk(mbp0), iset(mbp0), idel(mbp0)

      logical Lin, lqcInside

      character*80 subnam
      data subnam /'FSUMXQ ( ISET, DEF, X, QMU2, ICHK )'/

C--   Initialize flagbits
      if(first) then
        call sqcMakeFl(subnam,ichk,iset,idel)
        first = .false.
      endif
C--   Check pdf set
      call sqcIlele(subnam,'ISET',1,jset,mset0,' ')      
C--   Check status bits
      call sqcChkflg(jset,ichk,subnam)

      fsumxq = qnull6   !avoid compiler warning                  

      Lin = lqcInside(xx,qq,ifail)
      if(Lin)                     then
C--     x and qmu2 inside grid            
        fsumxq = dqcSumQQByt(jset,def,-log(xx),log(qq))
        
      elseif(jchk.ne.0)           then
C--     x or qmu2 outside grid gives fatal error 
        call sqcCutMsg(subnam,xx,qq,ifail,0)
        
      else 
C--     x or qmu2 outside grid sets pdfs to null         
        fsumxq = qnull6
      endif
      
      return
      end
      
C     =====================================================
      double precision function fsumij(jset,def,ix,iq,jchk)
C     =====================================================

C--   Weighted sum of quarks and antiquarks
C--
C--   Input    jset    : pdf set [1-9]
C--            jchk # 0: error if xx,qq out of range
C--                 = 0: return null if xx,qq out of range

      implicit double precision (a-h,o-z)

      include 'qcdnum.inc'
      include 'qgrid2.inc'
      include 'qpars6.inc'
      include 'qpdfs7.inc'

      dimension def(-6:6)
 
      logical first
      save    first
      data    first /.true./

      save      ichk,       iset,       idel
      dimension ichk(mbp0), iset(mbp0), idel(mbp0)

      character*80 subnam
      data subnam /'FSUMIJ ( ISET, DEF, IX, IQ, ICHK )'/

C--   Initialize flagbits
      if(first) then
        call sqcMakeFl(subnam,ichk,iset,idel)
        first = .false.
      endif
C--   Check pdf set
      call sqcIlele(subnam,'ISET',1,jset,mset0,' ')      
C--   Check status bits
      call sqcChkflg(jset,ichk,subnam)
C--   Check user input
      ixmi = nyy2(0)+1-iymac2
      iqmi = itfiz2(izmic2)
      iqma = itfiz2(izmac2)
      if(jchk.ne.0) then
        call sqcIlele(subnam,'IX', ixmi, ix, nyy2(0), ' ')
        iy = nyy2(0)+1-ix
        call sqcIlele(subnam,'IQ', iqmi, iq, iqma,' ')
        it = iq
      else
        fsumij = qnull6
        if(ix.lt.ixmi .or. ix.gt.nyy2(0))    return !ix out of range
        iy = nyy2(0)+1-ix
        if(iq.lt.iqmi .or. iq.gt.iqma)       return !iq out of range
        it = iq
      endif
      
C--   Go ...
      fsumij = dqcSumQQBij(jset,def,iy,it)
      
      return
      end
      
C     ===============================================
      double precision function fsplne(jset,id,xx,iq)
C     ===============================================

C--   Spline interpolation in x
C--
C--   jset   (in) : pdf set [1-9]
C--   id     (in) : si/ns pdf identifier [0-12]
C--   xx     (in) : value of x
C--   iq     (in) : iq grid point

      implicit double precision (a-h,o-z)

      include 'qcdnum.inc'
      include 'qgrid2.inc'
      include 'qpars6.inc'
      include 'qpdfs7.inc'

      logical first
      save    first
      data    first /.true./

      save      ichk,       iset,       idel
      dimension ichk(mbp0), iset(mbp0), idel(mbp0)

      character*80 subnam
      data subnam /'FSPLNE ( ISET, ID, X, QMU2 )'/

C--   Initialize flagbits
      if(first) then
        call sqcMakeFl(subnam,ichk,iset,idel)
        first = .false.
      endif
C--   Check pdf set
      call sqcIlele(subnam,'ISET',1,jset,mset0,' ')      
C--   Check status bits
      call sqcChkflg(jset,ichk,subnam)
C--   Check user input
      call sqcDltlt(subnam,'X', 0.D0, xx, 1.D0, ' ')
      yy = -log(xx)
      call sqcDltle(subnam,'-ln(X)', 0.D0, yy, ymaxc2,
     +              'X out of range')
      iqmi = itfiz2(izmic2)
      iqma = itfiz2(izmac2)
      call sqcIlele(subnam,'IQ', iqmi, iq, iqma,' ')
      it = iq
      
C--   Go ...
      fsplne  = dqcXSplne(jset,id,yy,it)
      
      return
      end
      
C     ============================================
      double precision function splchk(jset,id,iq)
C     ============================================

C--   Check for spline oscillations
C--
C--   jset  (in)  Pdf set [1-9]
C--   id    (in)  Si/ns pdf identifier [0-12]
C--   iq    (in)  mu2 grid point

      implicit double precision (a-h,o-z)

      include 'qcdnum.inc'
      include 'qgrid2.inc'
      include 'qpars6.inc'
      include 'qpdfs7.inc'

      logical first
      save    first
      data    first /.true./

      save      ichk,       iset,       idel
      dimension ichk(mbp0), iset(mbp0), idel(mbp0)

      character*80 subnam
      data subnam /'SPLCHK ( ISET, ID, IQ )'/

C--   Initialize flagbits
      if(first) then
        call sqcMakeFl(subnam,ichk,iset,idel)
        first = .false.
      endif
C--   Check pdf set
      call sqcIlele(subnam,'ISET',1,jset,mset0,' ')      
C--   Check status bits
      call sqcChkflg(jset,ichk,subnam)
C--   Check user input
      call sqcIlele(subnam,'ID', 0, id, 12  ,' ')
      call sqcIlele(subnam,'IQ', 1, iq, ntt2,' ')
C--   Go ...
      iqmi = itfiz2(izmic2)
      iqma = itfiz2(izmac2)
      if(iq.lt.iqmi .or. iq.gt.iqma) then
         splchk = 0.D0
      else   
         splchk = dqcSplChk(jset,id,iq)
      endif   
      
      return
      end
      
C==   ===============================================================
C==   Fast pdf interpolation  =======================================
C==   ===============================================================
            
C     ========================================      
      subroutine PdfLst(jset,def,x,q,f,n,jchk)
C     ========================================

C--   Process list of interpolation points.
C--   The number of interpolations can be larger than mpt0 since
C--   this routine autmatically buffers in chunks of mpt0 words.
C--
C--   jset       (in)   pdf set [1-9]
C--   def(-6:6)  (in)   coefficients, ..., sb, ub, db, g, d, u, s, ...
C--                     for gluon  set def(0) = non-zero
C--                     for quarks set def(0) = 0.D0   
C--   x          (in)   list of x-points
C--   q          (in)   list of mu2 points
C--   f          (out)  list of interpolated pdfs
C--   n          (in)   number of items in the list
C--   jchk       (in)   0/1  no/yes check grid boundary  
      
      implicit double precision (a-h,o-z)
      
      include 'qcdnum.inc'            
      
      dimension xx(mpt0),qq(mpt0)
      dimension def(-6:6), coef(0:12,3:6)
      dimension x(*), q(*), f(*)
      
      logical first
      save    first
      data    first /.true./

      save      ichk,       iset,       idel
      dimension ichk(mbp0), iset(mbp0), idel(mbp0)

      character*80 subnam
      data subnam /'PDFLST ( ISET, DEF, X, Q, F, N, ICHK )'/

C--   Initialize flagbits
      if(first) then
        call sqcMakeFl(subnam,ichk,iset,idel)
        first = .false.
      endif
C--   Check pdf set
      call sqcIlele(subnam,'ISET',1,jset,mset0,' ')      
C--   Check status bits
      call sqcChkflg(jset,ichk,subnam)
C--   Check user input
      if(n.le.0) call sqcErrMsg(subnam,'N should be larger than zero')
C--   Book scratch buffers
      call sqcUFBook(subnam)                  

C--   Translate the coefficients def(-6:6) from flavour space to 
C--   singlet/non-singlet space
      if(def(0).eq.0.D0) then                !quarks
        do nf = 3,6
          coef(0,nf) = 0.D0                  
          call efromqq(def, coef(1,nf), nf) 
        enddo
      else                                   !gluon
        do nf = 3,6
          coef(0,nf) = def(0)
          do i = 1,12
            coef(i,nf) = 0.D0 
          enddo  
        enddo
      endif  
      
C--   Fill output array f in batches of mpt0 words
      ipt = 0
      jj  = 0      
      do i = 1,n
        ipt     = ipt+1
        xx(ipt) = x(i)
        qq(ipt) = q(i)
        if(ipt.eq.mpt0) then
          call sqcUFIni(subnam,xx,qq,mpt0,jchk)  !interpolation points
          call sqcFastPdf(jset,coef,1,0)         !fill sparse buffer 1
          call sqcFastFxq(0,1,f(jj*mpt0+1),mpt0) !interpolate
          ipt = 0
          jj  = jj+1
        endif
      enddo
C--   Flush remaining ipt points
      if(ipt.ne.0) then
        call sqcUFIni(subnam,xx,qq,ipt,jchk)     !interpolation points 
        call sqcFastPdf(jset,coef,1,0)           !fill sparse buffer 1
        call sqcFastFxq(0,1,f(jj*mpt0+1),ipt)    !interpolate        
      endif
      
      return
      end
      
C     ================================================
      subroutine PdfTab(jset,def,xx,nx,qq,nq,pdf,jchk)
C     ================================================

C--   Pdf linear combination interpolated on a grid
C--
C--   jset   (in)   pdf set [1-9]
C--   def    (in)   def(-6:6) coefficients of linear combination
C--                     for gluon  set def(0) = non-zero
C--                     for quarks set def(0) = 0.D0 
C--   xx     (in)   input array of x-values
C--   nx     (in)   dimension of xx in the calling routine
C--   qq     (in)   input array of mu2-values
C--   nq     (in)   dimension of qq in the calling routine
C--   pdf    (out)  pdf(nx,nq) 2-dim array of interpolated pdfs
C--   jchk   (in)   # 0: error if xx,qq out of range
C--                 = 0: return null if xx,qq out of range

      implicit double precision (a-h,o-z)

      include 'qcdnum.inc'
      include 'qgrid2.inc'
      include 'qpars6.inc'

      dimension def(-6:6)
 
      logical first
      save    first
      data    first /.true./

      save      ichk,       iset,       idel
      dimension ichk(mbp0), iset(mbp0), idel(mbp0)
      
      dimension xx(nx), qq(nq), pdf(nx,nq),fff(nx*nq) 
      
      character*80 subnam
      data subnam /'PDFTAB ( ISET, DEF, XX, NX, QQ, NQ, PDF, ICHK )'/

C--   Initialize flagbits
      if(first) then
        call sqcMakeFl(subnam,ichk,iset,idel)
        first = .false.
      endif
C--   Check pdf set
      call sqcIlele(subnam,'ISET',1,jset,mset0,' ')      
C--   Check status bits
      call sqcChkflg(jset,ichk,subnam)
C--   Check user input
      if(nx.le.0) call sqcErrMsg(subnam,'NX .le. 0 not allowed')
      if(nq.le.0) call sqcErrMsg(subnam,'NQ .le. 0 not allowed')
C--   Findout x-range
      xmi = xminc2
      xma = xmaxc2    !exclude x = 1
      call sqcRange(xx,nx,xmi,xma,aepsi6,ixmi,ixma,ierrx)
      if(ierrx.eq.2) 
     +    call sqcErrMsg(subnam,'XX not in strictly ascending order')
      if(jchk.ne.0 .and. (ixmi.ne.1 .or. ixma.ne.nx))
     +    call sqcErrMsg(subnam,'At least one XX(i) out of range') 
C--   Findout mu2-range
      qmi = qminc2
      qma = qmaxc2
      call sqcRange(qq,nq,qmi,qma,aepsi6,iqmi,iqma,ierrq)
      if(ierrq.eq.2) 
     +    call sqcErrMsg(subnam,'QQ not in strictly ascending order')
      if(jchk.ne.0 .and. (iqmi.ne.1 .or. iqma.ne.nq))
     +    call sqcErrMsg(subnam,'At least one QQ(i) out of range')
C--   Preset output table
      do iq = 1,nq
        do ix = 1,nx
          pdf(ix,iq) = qnull6
        enddo            
      enddo
C--   x or qmu2 completely out of range
      if(ierrx.ne.0 .or. ierrq.ne.0) return
      
C--   Now do the work
      nxx = ixma-ixmi+1
      nqq = iqma-iqmi+1
      call sqcPdfTab(jset,def,xx(ixmi),nxx,qq(iqmi),nqq,fff)
      
C--   Now copy linear store fff(i) to pdf(ix,iq)
      i = 0
      do iq = iqmi,iqma
        do ix = ixmi,ixma
          i = i+1
          pdf(ix,iq) = fff(i)
        enddo
      enddo         
      
      return
      end
      
C==   ===============================================================
C==   External pdf input ============================================
C==   ===============================================================
      
C     ===============================================
      subroutine PdfInp(subr,jset,offset,epsi,nwlast)
C     ===============================================

C--   Read pdfs into memory
C--
C--   subr    (external) user supplied subroutine
C--   jset    (in)       pdf set [5-9]
C--   offset  (in)       threshold offset mu2h*(1+-delta)
C--   epsi    (out)      estimate of spline accuracy
C--   nwlast  (out)      last word occupied in the store (<0 no space)
C--
C--   subr(x,mu2,qqbar) should return qqbar(-6:6)   ... ub, db, gl, d, u, ...

      implicit double precision (a-h,o-z)

      external subr

      include 'qcdnum.inc'
      include 'qluns1.inc'
      include 'qgrid2.inc'
      include 'qsflg4.inc'
      include 'qibit4.inc'
      include 'qpars6.inc'
      include 'qstor7.inc'
      include 'qpdfs7.inc'
      include 'qmaps8.inc'

      logical first
      save    first
      data    first /.true./
      
      character*60 emsg
      character*10 etxt

      save      ichk,       iset,       idel
      dimension ichk(mbp0), iset(mbp0), idel(mbp0)

      character*80 subnam
      data subnam /'PDFINP ( SUBR, ISET, DELTA, EPSI, NWDS )'/

C--   Initialize flagbits
      if(first) then
        call sqcMakeFl(subnam,ichk,iset,idel)
        first = .false.
      endif

C--   Check pdf set in range
      call sqcIlele(subnam,'ISET',5,jset,mset0,' ')

C--   Check status bits
      call sqcChkflg(jset,ichk,subnam)
      
C--   Invalidate pdfs in jset
C--   This blocks access to jset via subr
      call sqcDelbit(ibPdfs4,istat4(1,jset),mbp0)

C--   Setup flavor map
      if(.not.Lnfmap8) call sqcNfTab(0)
C--   Make sure astable exists
      if(.not.Lastab8) call sqcAlfTab(iord6)      
C--   Initialize store
      if(.not.Lwtini8) call sqcIniWt
C--   Define kinematic plane
      if(.not.Levcut8) call sqcEvCuts(0)       

C--   Off we go...
      call sqcPdfInp(subr,jset,offset,epsi,nwlast,ierr)

C--   Not enough space      
      if(nwlast.le.0) then
        call smb_itoch(abs(nwlast),etxt,ltxt)
        write(emsg,'(''Need at least '',A,
     &    '' words --> increase NWF0 '',
     &    ''in qcdnum.inc'')') etxt(1:ltxt)
        call sqcErrMsg(subnam,emsg)
      endif
      
C--   Check max deviation
      if(dflim6.gt.0.D0 .and. epsi.gt.dflim6) call sqcErrMsg(subnam, 
     +          'Possible spline oscillation detected')
      
C--   Update status bits
      call sqcSetflg(iset,idel,jset)
      
      return
      end
      
